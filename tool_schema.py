"""
Temporary tool schema definitions for validation.

⚠️ PHASE 1 BRIDGE: This is a stopgap schema until Phase 2 generates
a canonical obsidian_tools.schema.json from obsidian_functions.py.

This schema covers the commonly-used tools with validation, checking only
required fields and basic types. Uncovered tools are allowed through with
a warning log (warn-but-allow strategy).

DO NOT edit this file manually beyond Phase 1. Once Phase 2 launches,
this should be AUTO-GENERATED from OBSIDIAN_FUNCTIONS.
"""

import structlog
from typing import Dict, List, Any

logger = structlog.get_logger()

TOOL_SCHEMA = {
    "append_to_daily_note": {
        "required": ["content"],
        "properties": {
            "content": {"type": "string", "description": "The content to add to the daily note"},
            "section": {
                "type": "string",
                "enum": ["Quick Captures", "Work Notes", "Personal Notes", "Tasks"],
                "description": "Which section of the daily note to add to"
            },
            "date": {
                "type": "string",
                "description": "Optional date in YYYY-MM-DD format. Defaults to today."
            }
        },
        "example": {"content": "Remember to call John", "section": "Tasks"}
    },
    "create_simple_note": {
        "required": ["title", "content", "folder"],
        "properties": {
            "title": {"type": "string", "description": "The title/name of the note"},
            "content": {"type": "string", "description": "The markdown content for the note"},
            "folder": {"type": "string", "description": "Which folder to create the note in"}
        },
        "example": {"title": "Docker Notes", "content": "## Setup\n\n...", "folder": "Homelab"}
    },
    # create_job_note removed - deprecated in vault migration
    "read_note": {
        "required": ["file_path"],
        "properties": {
            "file_path": {"type": "string", "description": "The file path relative to vault (use get_vault_structure to discover folders)"}
        },
        "example": {"file_path": "Notes/Docker Setup.md"}
    },
    "delete_note": {
        "required": ["file_path"],
        "properties": {
            "file_path": {"type": "string", "description": "The file path relative to vault"},
            "dry_run": {"type": "boolean", "description": "If true, preview deletion without actually deleting"}
        },
        "example": {"file_path": "Notes/Old Note.md", "dry_run": True}
    },
    "create_from_template": {
        "required": ["template_name", "destination"],
        "properties": {
            "template_name": {"type": "string", "description": "Name of the template to use (use list_templates to discover)"},
            "destination": {"type": "string", "description": "Folder or file path where to create the note (use get_vault_structure to discover)"}
        },
        "example": {"template_name": "Meeting Notes", "destination": "Projects"}
    },
    "update_note": {
        "required": ["file_path", "new_content"],
        "properties": {
            "file_path": {"type": "string", "description": "Relative path to the note (e.g., 'Folder/Note.md')"},
            "new_content": {"type": "string", "description": "New content to write to the note"},
            "mode": {
                "type": "string",
                "enum": ["overwrite", "append", "replace"],
                "description": "How to apply the update. overwrite=replace entire file, append=add to end, replace=old_text→new_content"
            },
            "old_text": {
                "type": "string",
                "description": "Required when mode='replace': the exact text to replace"
            }
        },
        "example": {
            "file_path": "Notes/Example.md",
            "new_content": "Updated note content",
            "mode": "overwrite"
        }
    }
}


def validate_tool_call(function_name: str, arguments: Dict[str, Any]) -> tuple[bool, str]:
    """
    Pre-execution validation: check function name and required fields.
    
    Uses a "warn-but-allow" strategy for functions not in TOOL_SCHEMA:
    - Functions with schemas: validate required fields, reject if missing
    - Functions without schemas: log warning, allow execution to proceed
    
    Returns: (is_valid, error_message)
    """
    
    if function_name not in TOOL_SCHEMA:
        # Warn but allow - log that this function lacks schema coverage
        logger.warning(
            "tool_schema_uncovered",
            function=function_name,
            message=f"Function '{function_name}' has no schema defined. Skipping validation.",
            args_keys=list(arguments.keys()) if arguments else []
        )
        return True, ""
    
    schema = TOOL_SCHEMA[function_name]
    required = schema.get("required", [])
    
    missing = set(required) - set(arguments.keys())
    if missing:
        example = schema.get("example", {})
        missing_str = ", ".join(sorted(missing))
        example_str = ", ".join(f"{k}={repr(v)}" for k, v in example.items())
        return False, (
            f"Missing required field(s) for {function_name}: {missing_str}. "
            f"Example: {{{example_str}}}"
        )
    
    return True, ""


def get_schema_for_function(function_name: str) -> Dict[str, Any]:
    """Get the schema definition for a specific function, or None if not defined."""
    return TOOL_SCHEMA.get(function_name)


def list_schema_functions() -> List[str]:
    """Return list of all functions with schemas defined."""
    return list(TOOL_SCHEMA.keys())
